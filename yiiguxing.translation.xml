<application>
  <component name="AppStorage">
    <histories>
      <item value="schedule With Fixed Delay" />
      <item value="schedule At Fixed Rate" />
      <item value="轮盘" />
      <item value="转盘" />
      <item value="Count Down Latch" />
      <item value="credit" />
      <item value="计入" />
      <item value="时间片" />
      <item value="Rolling Number" />
      <item value="转轮" />
      <item value="counter" />
      <item value="One or more variables that together maintain an initially zero {@code long} sum. When updates (method {@link add}) are contended across threads, the set of variables may grow dynamically to reduce contention. Method {@link sum} (or, equivalently, {@link longValue}) returns the current total combined across the variables maintaining the sum. &lt;p&gt;This class is usually preferable to {@link AtomicLong} when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption. &lt;p&gt;LongAdders can be used with a {@link java.util.concurrent.ConcurrentHashMap} to maintain a scalable frequency map (a form of histogram or multiset). For example, to add a count to a {@code ConcurrentHashMap&lt;String,LongAdder&gt; freqs}, initializing if not already present, you can use {@code freqs.computeIfAbsent(k -&gt; new LongAdder()).increment();} &lt;p&gt;This class extends {@link Number}, but does &lt;em&gt;not&lt;em&gt; define methods such as {@code equals}, {@code hashCode} and {@code compareTo} because instances are expected to be mutated, and so are not useful as collection keys. @since 1.8 @author Doug Lea" />
      <item value="Bucket" />
      <item value="start Learn" />
      <item value="同步请求次数" />
      <item value="duration" />
      <item value="spent Time" />
      <item value="enable" />
      <item value="enabled" />
      <item value="executor Minutes" />
      <item value="label" />
      <item value="Labor Work Repair Data Ctrl" />
      <item value="event Collect" />
      <item value="exist" />
      <item value="check Is Inited" />
      <item value="username" />
      <item value="time Period" />
      <item value="互相批阅数" />
      <item value="学习时长" />
      <item value="avatar" />
      <item value="yield" />
      <item value="predicate" />
      <item value="labor" />
      <item value="labour" />
      <item value="duplicate Check" />
      <item value="collective Labour Detail Preview" />
      <item value="查重通过标记" />
      <item value="是否查重通过标记" />
      <item value="repeat Check Pass Flag" />
      <item value="查重通过" />
      <item value="repeat Pass Flag" />
      <item value="is Repeat" />
      <item value="是否重复" />
      <item value="相似度" />
      <item value="repair Sim Hash" />
      <item value="Post onboarding request, to setup initial user, org and bucket. @param url the url to connect to the InfluxDB @param username the name of an user @param password the password to connect as an user @param org the name of an organization @param bucket the name of a bucket @return Created default user, bucket, org." />
      <item value="Write Precision" />
      <item value="bucket" />
      <item value="specifies the destination organization for writes" />
      <item value="Creates a new instance of the class represented by this {@code Class} object. The class is instantiated as if by a {@code new} expression with an empty argument list. The class is initialized if it has not already been initialized. @deprecated This method propagates any exception thrown by the nullary constructor, including a checked exception. Use of this method effectively bypasses the compile-time exception checking that would otherwise be performed by the compiler. The {@link java.lang.reflect.ConstructornewInstance(java.lang.Object...) Constructor.newInstance} method avoids this problem by wrapping any exception thrown by the constructor in a (checked) {@link java.lang.reflect.InvocationTargetException}. &lt;p&gt;The call &lt;pre&gt;{@code clazz.newInstance() }&lt;pre&gt; can be replaced by &lt;pre&gt;{@code clazz.getDeclaredConstructor().newInstance() }&lt;pre&gt; The latter sequence of calls is inferred to be able to throw the additional exception types {@link InvocationTargetException} and {@link NoSuchMethodException}. Both of these exception types are subclasses of {@link ReflectiveOperationException}. @return a newly allocated instance of the class represented by this object. @throws IllegalAccessException if the class or its nullary constructor is not accessible. @throws InstantiationException if this {@code Class} represents an abstract class, an interface, an array class, a primitive type, or void; or if the class has no nullary constructor; or if the instantiation fails for some other reason. @throws ExceptionInInitializerError if the initialization provoked by this method fails. @throws SecurityException If a security manager, &lt;i&gt;s&lt;i&gt;, is present and the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of {@link SecurityManagercheckPackageAccess s.checkPackageAccess()} denies access to the package of this class." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="161" />
        <entry key="ENGLISH" value="162" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="JAPANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1624865002058" />
  </component>
</application>