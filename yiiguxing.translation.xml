<application>
  <component name="AppStorage">
    <histories>
      <item value="sender Preview File" />
      <item value="Points Channel" />
      <item value="Channel" />
      <item value="set Sum With Delta" />
      <item value="已获得的积分" />
      <item value="channel" />
      <item value="filter" />
      <item value="qps Exclude Url" />
      <item value="minus Seconds" />
      <item value="schedule With Fixed Delay" />
      <item value="schedule At Fixed Rate" />
      <item value="轮盘" />
      <item value="转盘" />
      <item value="Count Down Latch" />
      <item value="credit" />
      <item value="计入" />
      <item value="时间片" />
      <item value="Rolling Number" />
      <item value="转轮" />
      <item value="counter" />
      <item value="One or more variables that together maintain an initially zero {@code long} sum. When updates (method {@link add}) are contended across threads, the set of variables may grow dynamically to reduce contention. Method {@link sum} (or, equivalently, {@link longValue}) returns the current total combined across the variables maintaining the sum. &lt;p&gt;This class is usually preferable to {@link AtomicLong} when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption. &lt;p&gt;LongAdders can be used with a {@link java.util.concurrent.ConcurrentHashMap} to maintain a scalable frequency map (a form of histogram or multiset). For example, to add a count to a {@code ConcurrentHashMap&lt;String,LongAdder&gt; freqs}, initializing if not already present, you can use {@code freqs.computeIfAbsent(k -&gt; new LongAdder()).increment();} &lt;p&gt;This class extends {@link Number}, but does &lt;em&gt;not&lt;em&gt; define methods such as {@code equals}, {@code hashCode} and {@code compareTo} because instances are expected to be mutated, and so are not useful as collection keys. @since 1.8 @author Doug Lea" />
      <item value="Bucket" />
      <item value="start Learn" />
      <item value="同步请求次数" />
      <item value="duration" />
      <item value="spent Time" />
      <item value="enable" />
      <item value="enabled" />
      <item value="executor Minutes" />
      <item value="label" />
      <item value="Labor Work Repair Data Ctrl" />
      <item value="event Collect" />
      <item value="exist" />
      <item value="check Is Inited" />
      <item value="username" />
      <item value="time Period" />
      <item value="互相批阅数" />
      <item value="学习时长" />
      <item value="avatar" />
      <item value="yield" />
      <item value="predicate" />
      <item value="labor" />
      <item value="labour" />
      <item value="duplicate Check" />
      <item value="collective Labour Detail Preview" />
      <item value="查重通过标记" />
      <item value="是否查重通过标记" />
      <item value="repeat Check Pass Flag" />
      <item value="查重通过" />
      <item value="repeat Pass Flag" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="161" />
        <entry key="ENGLISH" value="162" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="JAPANESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1625537307333" />
  </component>
</application>